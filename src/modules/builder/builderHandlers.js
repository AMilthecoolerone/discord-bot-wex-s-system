import { 
  ActionRowBuilder, 
  ButtonBuilder, 
  ButtonStyle, 
  EmbedBuilder, 
  ModalBuilder, 
  TextInputBuilder, 
  TextInputStyle 
} from 'discord.js';
import { config } from '../../config/index.js';
import { logger } from '../../utils/logger.js';
import { 
  findActiveApplicationByUser, 
  findApplicationByUser,
  createBuilderApplication, 
  updateBuilderApplication 
} from './builderModel.js';

// All 12 questions exactly as specified (VERBATIM)
export const QUESTIONS = [
  '1/12. What is your Donutsmp.net Networth ?',
  '2/12. What is your In Game Name ?',
  '3/12. How many hours a week can you spend building ?',
  '4/12. How well can you communicate in English ?',
  '5/12. Do you have access to the Mod \'Litematica\' ?',
  '6/12. Do you have any servers where you are trusted ?',
  '7/12. Do you have any vouches ?',
  '8/12. If a customer gets mad at you, can you control your temper ?',
  '9/12. If a customer is unhappy with the finished product, what would you do ?',
  '10/12. What is the best farm you have built ?',
  '11/12. What separates you and a different builder ?',
  '12/12. Any applications using AI will instantly be denied, thanks for applying !',
];

// AI detection keywords (admission-based only)
const AI_KEYWORDS = ['ai', 'artificial intelligence', 'chatgpt', 'gpt', 'claude', 'copilot', 'used ai', 'used artificial intelligence', 'generated by ai', 'ai generated'];

function checkForAIAdmission(text) {
  if (!text) return false;
  const lowerText = text.toLowerCase();
  return AI_KEYWORDS.some(keyword => lowerText.includes(keyword));
}

// Get staff review channel
async function getReviewChannel(guild) {
  // Try to find by name first
  let channel = guild.channels.cache.find(
    c => c.name === config.builderReviewChannel && c.isTextBased()
  );
  
  // If not found, try to get from settings (similar to modlog)
  if (!channel) {
    const { getSettings } = await import('../../utils/settings.js');
    const settings = await getSettings(guild.id);
    if (settings.builderReviewChannelId) {
      const byId = guild.channels.cache.get(settings.builderReviewChannelId);
      if (byId && byId.isTextBased()) channel = byId;
    }
  }
  
  return channel;
}

// Send application to staff review channel
async function sendToReviewChannel(guild, application, user, autoRejected = false) {
  const reviewChannel = await getReviewChannel(guild);
  
  if (!reviewChannel) {
    logger.error(`Builder review channel not found for guild ${guild.id}`);
    return false;
  }

  const status = autoRejected ? 'AUTO-REJECTED (AI Usage)' : 'PENDING REVIEW';
  const statusColor = autoRejected ? '#FF0000' : config.embedColor;

  const submittedAt = application.submittedAt instanceof Date 
    ? application.submittedAt 
    : new Date(application.submittedAt || Date.now());
  
  const applicationId = application.applicationId || 'N/A';
  
  const embed = new EmbedBuilder()
    .setTitle('üèóÔ∏è Builder Application')
    .setColor(statusColor)
    .addFields(
      { name: 'Application ID', value: `\`${applicationId}\``, inline: true },
      { name: 'Applicant', value: `<@${user.id}> (${user.tag})\nID: ${user.id}`, inline: true },
      { name: 'Status', value: status, inline: true },
      { name: 'Submitted', value: `<t:${Math.floor(submittedAt.getTime() / 1000)}:F>`, inline: false }
    );

  // Add all questions and answers
  const answers = application.answers instanceof Map 
    ? Object.fromEntries(application.answers) 
    : application.answers;
  
  for (let i = 0; i < QUESTIONS.length; i++) {
    const questionNum = i + 1;
    const answer = answers[`question_${questionNum}`] || 'No answer provided';
    
    // Truncate if too long (Discord field limit is 1024 characters)
    const displayAnswer = answer.length > 1000 ? answer.substring(0, 997) + '...' : answer;
    
    embed.addFields({
      name: QUESTIONS[i],
      value: displayAnswer || 'No answer provided',
      inline: false
    });
  }

  if (autoRejected && application.rejectionReason) {
    embed.addFields({
      name: 'Rejection Reason',
      value: application.rejectionReason,
      inline: false
    });
  }

  embed.setTimestamp(submittedAt);

  await reviewChannel.send({ embeds: [embed] }).catch(err => {
    logger.error('Failed to send builder application to review channel', err);
    return false;
  });

  return true;
}

// Handle button click to start application
export async function handleBuilderButton(interaction) {
  try {
    const { guild, user, customId } = interaction;
    
    if (customId === 'builder_apply_start') {
      logger.info(`Builder application started by ${user.tag} (${user.id}) in guild ${guild.id}`);
      
      if (!guild) {
        return interaction.reply({ 
          content: '‚ùå This command can only be used in a server.', 
          ephemeral: true 
        });
      }
      
      // Check for existing pending application (allow re-application after rejection)
      const existing = await findActiveApplicationByUser(guild.id, user.id).catch(err => {
        logger.error('Error checking for existing application', err);
        return null;
      });
      
      if (existing) {
        return interaction.reply({ 
          content: '‚ùå You already have a pending builder application. Please wait for staff review before submitting a new one.', 
          ephemeral: true 
        });
      }

    // Show first modal (Questions 1-5)
    const modal = new ModalBuilder()
      .setCustomId('builder_modal_1')
      .setTitle('Builder Application - Questions 1-5');

    const q1 = new TextInputBuilder()
      .setCustomId('question_1')
      .setLabel('1. Networth')
      .setStyle(TextInputStyle.Short)
      .setRequired(true)
      .setPlaceholder('What is your Donutsmp.net Networth?');

    const q2 = new TextInputBuilder()
      .setCustomId('question_2')
      .setLabel('2. In Game Name')
      .setStyle(TextInputStyle.Short)
      .setRequired(true)
      .setPlaceholder('What is your In Game Name?');

    const q3 = new TextInputBuilder()
      .setCustomId('question_3')
      .setLabel('3. Hours per week')
      .setStyle(TextInputStyle.Short)
      .setRequired(true)
      .setPlaceholder('How many hours a week can you spend building?');

    const q4 = new TextInputBuilder()
      .setCustomId('question_4')
      .setLabel('4. English communication')
      .setStyle(TextInputStyle.Paragraph)
      .setRequired(true)
      .setPlaceholder('How well can you communicate in English?');

    const q5 = new TextInputBuilder()
      .setCustomId('question_5')
      .setLabel('5. Litematica access')
      .setStyle(TextInputStyle.Short)
      .setRequired(true)
      .setPlaceholder('Do you have access to the Mod \'Litematica\'?');

    modal.addComponents(
      new ActionRowBuilder().addComponents(q1),
      new ActionRowBuilder().addComponents(q2),
      new ActionRowBuilder().addComponents(q3),
      new ActionRowBuilder().addComponents(q4),
      new ActionRowBuilder().addComponents(q5)
    );

      await interaction.showModal(modal);
    }
  } catch (err) {
    logger.error('Error in handleBuilderButton', err);
    if (!interaction.replied && !interaction.deferred) {
      await interaction.reply({ 
        content: '‚ùå An error occurred while starting your application. Please try again later.', 
        ephemeral: true 
      }).catch(() => {});
    }
  }
}

// Handle modal submissions
export async function handleBuilderModal(interaction) {
  try {
    const { guild, user, customId, fields } = interaction;
    
    if (!customId.startsWith('builder_modal_')) return;
    
    if (!guild) {
      return interaction.reply({ 
        content: '‚ùå This command can only be used in a server.', 
        ephemeral: true 
      });
    }
    
    const modalNumber = parseInt(customId.replace('builder_modal_', ''));
    
    if (isNaN(modalNumber) || modalNumber < 1 || modalNumber > 3) {
      logger.warn(`Invalid modal number: ${modalNumber} from user ${user.id}`);
      return interaction.reply({ 
        content: '‚ùå Invalid application form. Please start a new application.', 
        ephemeral: true 
      });
    }
    
    logger.info(`Builder application modal ${modalNumber} submitted by ${user.tag} (${user.id})`);

  // Get existing application or create empty answers map
  let existingApp = await findApplicationByUser(guild.id, user.id);
  let answers = existingApp 
    ? (existingApp.answers instanceof Map 
        ? new Map(existingApp.answers) 
        : new Map(Object.entries(existingApp.answers || {})))
    : new Map();
  
  // Save answers from current modal
  if (modalNumber === 1) {
    for (let i = 1; i <= 5; i++) {
      const value = fields.getTextInputValue(`question_${i}`) || '';
      answers.set(`question_${i}`, value);
    }
  } else if (modalNumber === 2) {
    for (let i = 6; i <= 9; i++) {
      const value = fields.getTextInputValue(`question_${i}`) || '';
      answers.set(`question_${i}`, value);
    }
  } else if (modalNumber === 3) {
    for (let i = 10; i <= 12; i++) {
      const value = fields.getTextInputValue(`question_${i}`) || '';
      answers.set(`question_${i}`, value);
    }
  }
  
  // Save answers to database
  if (!existingApp) {
    existingApp = await createBuilderApplication({
      guildId: guild.id,
      userId: user.id,
      answers: answers,
      status: 'pending',
      submittedAt: new Date()
    });
  } else {
    await updateBuilderApplication(
      { guildId: guild.id, userId: user.id },
      { $set: { answers: Object.fromEntries(answers) } }
    );
  }

  // Check for AI admission in ALL collected answers so far
  const currentAnswers = Object.fromEntries(answers);
  let aiDetected = false;
  let detectedInQuestion = null;
  
  for (const [key, value] of Object.entries(currentAnswers)) {
    if (checkForAIAdmission(value)) {
      aiDetected = true;
      detectedInQuestion = key;
      break;
    }
  }

  // Handle completion or progression
  if (modalNumber === 1) {
    // Show modal 2 (Questions 6-9)
    if (aiDetected) {
      // Auto-reject immediately
      await updateBuilderApplication(
        { guildId: guild.id, userId: user.id },
        { 
          $set: { 
            status: 'auto_rejected',
            autoRejected: true,
            rejectionReason: `AI usage detected in answer (Question ${detectedInQuestion}). Applications using AI are automatically denied.`
          } 
        }
      );
      // Reload application to get updated data
      const rejectedApp = await findApplicationByUser(guild.id, user.id);
      rejectedApp.status = 'auto_rejected';
      rejectedApp.autoRejected = true;
      rejectedApp.rejectionReason = `AI usage detected in answer (Question ${detectedInQuestion}). Applications using AI are automatically denied.`;
      
      const reviewSent = await sendToReviewChannel(guild, rejectedApp, user, true);
      if (reviewSent) {
        await interaction.reply({ 
          content: '‚ùå Your application has been automatically rejected due to AI usage. Any applications using AI will instantly be denied.', 
          ephemeral: true 
        });
        logger.info(`Builder application auto-rejected for AI usage: ${user.tag} (${user.id})`);
      } else {
        await interaction.reply({ 
          content: '‚ùå Your application was processed but there was an error sending it to the review channel. Please contact staff.', 
          ephemeral: true 
        });
      }
      return;
    }
    
    const modal2 = new ModalBuilder()
      .setCustomId('builder_modal_2')
      .setTitle('Builder Application - Questions 6-9');

    const q6 = new TextInputBuilder()
      .setCustomId('question_6')
      .setLabel('6. Trusted servers')
      .setStyle(TextInputStyle.Paragraph)
      .setRequired(true)
      .setPlaceholder('Do you have any servers where you are trusted?');

    const q7 = new TextInputBuilder()
      .setCustomId('question_7')
      .setLabel('7. Vouches')
      .setStyle(TextInputStyle.Paragraph)
      .setRequired(true)
      .setPlaceholder('Do you have any vouches?');

    const q8 = new TextInputBuilder()
      .setCustomId('question_8')
      .setLabel('8. Temper control')
      .setStyle(TextInputStyle.Paragraph)
      .setRequired(true)
      .setPlaceholder('If a customer gets mad at you, can you control your temper?');

    const q9 = new TextInputBuilder()
      .setCustomId('question_9')
      .setLabel('9. Unhappy customer')
      .setStyle(TextInputStyle.Paragraph)
      .setRequired(true)
      .setPlaceholder('If a customer is unhappy with the finished product, what would you do?');

    modal2.addComponents(
      new ActionRowBuilder().addComponents(q6),
      new ActionRowBuilder().addComponents(q7),
      new ActionRowBuilder().addComponents(q8),
      new ActionRowBuilder().addComponents(q9)
    );

    await interaction.showModal(modal2);
    
  } else if (modalNumber === 2) {
    // Check for AI again
    if (aiDetected) {
      await updateBuilderApplication(
        { guildId: guild.id, userId: user.id },
        { 
          $set: { 
            status: 'auto_rejected',
            autoRejected: true,
            rejectionReason: `AI usage detected in answer (Question ${detectedInQuestion}). Applications using AI are automatically denied.`
          } 
        }
      );
      // Reload application to get updated data
      const rejectedApp = await findApplicationByUser(guild.id, user.id);
      rejectedApp.status = 'auto_rejected';
      rejectedApp.autoRejected = true;
      rejectedApp.rejectionReason = `AI usage detected in answer (Question ${detectedInQuestion}). Applications using AI are automatically denied.`;
      
      const reviewSent = await sendToReviewChannel(guild, rejectedApp, user, true);
      if (reviewSent) {
        await interaction.reply({ 
          content: '‚ùå Your application has been automatically rejected due to AI usage. Any applications using AI will instantly be denied.', 
          ephemeral: true 
        });
        logger.info(`Builder application auto-rejected for AI usage: ${user.tag} (${user.id})`);
      } else {
        await interaction.reply({ 
          content: '‚ùå Your application was processed but there was an error sending it to the review channel. Please contact staff.', 
          ephemeral: true 
        });
      }
      return;
    }
    
    // Show modal 3 (Questions 10-12)
    const modal3 = new ModalBuilder()
      .setCustomId('builder_modal_3')
      .setTitle('Builder Application - Questions 10-12');

    const q10 = new TextInputBuilder()
      .setCustomId('question_10')
      .setLabel('10. Best farm built')
      .setStyle(TextInputStyle.Paragraph)
      .setRequired(true)
      .setPlaceholder('What is the best farm you have built?');

    const q11 = new TextInputBuilder()
      .setCustomId('question_11')
      .setLabel('11. What separates you')
      .setStyle(TextInputStyle.Paragraph)
      .setRequired(true)
      .setPlaceholder('What separates you and a different builder?');

    const q12 = new TextInputBuilder()
      .setCustomId('question_12')
      .setLabel('12. AI confirmation')
      .setStyle(TextInputStyle.Paragraph)
      .setRequired(true)
      .setPlaceholder('Any applications using AI will instantly be denied, thanks for applying!');

    modal3.addComponents(
      new ActionRowBuilder().addComponents(q10),
      new ActionRowBuilder().addComponents(q11),
      new ActionRowBuilder().addComponents(q12)
    );

    await interaction.showModal(modal3);
    
  } else if (modalNumber === 3) {
    // Final check for AI
    if (aiDetected) {
      await updateBuilderApplication(
        { guildId: guild.id, userId: user.id },
        { 
          $set: { 
            status: 'auto_rejected',
            autoRejected: true,
            rejectionReason: `AI usage detected in answer (Question ${detectedInQuestion}). Applications using AI are automatically denied.`
          } 
        }
      );
      // Reload application to get updated data
      const rejectedApp = await findApplicationByUser(guild.id, user.id);
      rejectedApp.status = 'auto_rejected';
      rejectedApp.autoRejected = true;
      rejectedApp.rejectionReason = `AI usage detected in answer (Question ${detectedInQuestion}). Applications using AI are automatically denied.`;
      
      const reviewSent = await sendToReviewChannel(guild, rejectedApp, user, true);
      if (reviewSent) {
        await interaction.reply({ 
          content: '‚ùå Your application has been automatically rejected due to AI usage. Any applications using AI will instantly be denied.', 
          ephemeral: true 
        });
        logger.info(`Builder application auto-rejected for AI usage: ${user.tag} (${user.id})`);
      } else {
        await interaction.reply({ 
          content: '‚ùå Your application was processed but there was an error sending it to the review channel. Please contact staff.', 
          ephemeral: true 
        });
      }
      return;
    }

    // Application completed - send to review
    await updateBuilderApplication(
      { guildId: guild.id, userId: user.id },
      { $set: { status: 'pending' } }
    );
    
    // Reload application to get all answers
    const fullApplication = await findApplicationByUser(guild.id, user.id);
    
    const reviewSent = await sendToReviewChannel(guild, fullApplication, user, false);
    if (reviewSent) {
      await interaction.reply({ 
        content: '‚úÖ Your builder application has been submitted successfully! Staff will review it shortly.', 
        ephemeral: true 
      });
      logger.info(`Builder application completed: ${user.tag} (${user.id}) in guild ${guild.id}`);
    } else {
      await interaction.reply({ 
        content: '‚ö†Ô∏è Your application was saved but there was an error sending it to the review channel. Please contact staff.', 
        ephemeral: true 
      });
      logger.error(`Failed to send builder application to review channel for ${user.tag} (${user.id})`);
    }
  }
  } catch (err) {
    logger.error('Error in handleBuilderModal', err);
    if (!interaction.replied && !interaction.deferred) {
      await interaction.reply({ 
        content: '‚ùå An error occurred while processing your application. Please try again later.', 
        ephemeral: true 
      }).catch(() => {});
    }
  }
}